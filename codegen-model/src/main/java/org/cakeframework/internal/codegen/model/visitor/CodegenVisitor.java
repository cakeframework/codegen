/*
 * Copyright (c) 2008 Kasper Nielsen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* 
 * This class was automatically generated by cake.bootstrap.codegen.model.GenerateModel 
 * Available in the https://github.com/cakeframework/cake-developers/ project 
 */
package org.cakeframework.internal.codegen.model.visitor;

import org.cakeframework.internal.codegen.model.AbstractASTNode;
import org.cakeframework.internal.codegen.model.PackageDeclaration;
import org.cakeframework.internal.codegen.model.body.FieldDeclaration;
import org.cakeframework.internal.codegen.model.body.InitializerDeclaration;
import org.cakeframework.internal.codegen.model.body.Parameter;
import org.cakeframework.internal.codegen.model.body.VariableDeclarator;
import org.cakeframework.internal.codegen.model.expression.ArrayAccessExpression;
import org.cakeframework.internal.codegen.model.expression.ArrayCreationExpression;
import org.cakeframework.internal.codegen.model.expression.AssignExpression;
import org.cakeframework.internal.codegen.model.expression.BinaryExpression;
import org.cakeframework.internal.codegen.model.expression.CastExpression;
import org.cakeframework.internal.codegen.model.expression.ClassExpression;
import org.cakeframework.internal.codegen.model.expression.ConditionalExpression;
import org.cakeframework.internal.codegen.model.expression.EncapsulatedExpression;
import org.cakeframework.internal.codegen.model.expression.Expression;
import org.cakeframework.internal.codegen.model.expression.FieldAccessExpression;
import org.cakeframework.internal.codegen.model.expression.InstanceOfExpression;
import org.cakeframework.internal.codegen.model.expression.Literal;
import org.cakeframework.internal.codegen.model.expression.MethodInvocation;
import org.cakeframework.internal.codegen.model.expression.NameExpression;
import org.cakeframework.internal.codegen.model.expression.NewInstanceExpression;
import org.cakeframework.internal.codegen.model.expression.SuperExpression;
import org.cakeframework.internal.codegen.model.expression.ThisExpression;
import org.cakeframework.internal.codegen.model.expression.UnaryExpression;
import org.cakeframework.internal.codegen.model.expression.VariableDeclarationExpression;
import org.cakeframework.internal.codegen.model.statement.AssertStatement;
import org.cakeframework.internal.codegen.model.statement.BlockStatement;
import org.cakeframework.internal.codegen.model.statement.BreakStatement;
import org.cakeframework.internal.codegen.model.statement.CatchClause;
import org.cakeframework.internal.codegen.model.statement.ContinueStatement;
import org.cakeframework.internal.codegen.model.statement.DoStatement;
import org.cakeframework.internal.codegen.model.statement.EmptyStatement;
import org.cakeframework.internal.codegen.model.statement.ExplicitConstructorInvocationStatement;
import org.cakeframework.internal.codegen.model.statement.ExpressionStatement;
import org.cakeframework.internal.codegen.model.statement.ForStatement;
import org.cakeframework.internal.codegen.model.statement.IfStatement;
import org.cakeframework.internal.codegen.model.statement.LabeledStatement;
import org.cakeframework.internal.codegen.model.statement.ReturnStatement;
import org.cakeframework.internal.codegen.model.statement.Statement;
import org.cakeframework.internal.codegen.model.statement.SwitchEntryStatement;
import org.cakeframework.internal.codegen.model.statement.SwitchStatement;
import org.cakeframework.internal.codegen.model.statement.SynchronizedStatement;
import org.cakeframework.internal.codegen.model.statement.TextLineStatement;
import org.cakeframework.internal.codegen.model.statement.ThrowStatement;
import org.cakeframework.internal.codegen.model.statement.TryStatement;
import org.cakeframework.internal.codegen.model.statement.WhileStatement;
import org.cakeframework.internal.codegen.model.type.ClassOrInterfaceType;
import org.cakeframework.internal.codegen.model.type.PrimitiveType;
import org.cakeframework.internal.codegen.model.type.ReferenceType;

/**
 * This class has been autogenerated
 *
 * @author Kasper Nielsen
 */
public abstract class CodegenVisitor {

    public void visit(PackageDeclaration n) {
        visitNodeBefore(n);
        n.getName().accept(this);
        visitNodeAfter(n);
    }

    public void visit(Parameter n) {
        visitNodeBefore(n);
        visitNodeAfter(n);
    }

    public void visit(InitializerDeclaration n) {
        visitNodeBefore(n);
        n.getBody().accept(this);
        visitNodeAfter(n);
    }

    public void visit(FieldDeclaration n) {
        visitNodeBefore(n);
        n.getType().accept(this);
        n.getDeclarators().accept(this);
        visitNodeAfter(n);
    }

    public void visit(VariableDeclarator n) {
        visitNodeBefore(n);
        n.getName().accept(this);
        n.getInit().accept(this);
        visitNodeAfter(n);
    }

    public void visit(ArrayCreationExpression n) {
        visitNodeBefore(n);
        n.getType().accept(this);
        for (Expression nn : n) {
            nn.accept(this);
        }
        visitNodeAfter(n);
    }

    public void visit(ArrayAccessExpression n) {
        visitNodeBefore(n);
        n.getArray().accept(this);
        for (Expression nn : n) {
            nn.accept(this);
        }
        visitNodeAfter(n);
    }

    public void visit(AssignExpression n) {
        visitNodeBefore(n);
        n.getLeft().accept(this);
        n.getRight().accept(this);
        visitNodeAfter(n);
    }

    public void visit(BinaryExpression n) {
        visitNodeBefore(n);
        n.getLeft().accept(this);
        n.getRight().accept(this);
        visitNodeAfter(n);
    }

    public void visit(CastExpression n) {
        visitNodeBefore(n);
        n.getType().accept(this);
        n.getExpression().accept(this);
        visitNodeAfter(n);
    }

    public void visit(ClassExpression n) {
        visitNodeBefore(n);
        n.getType().accept(this);
        visitNodeAfter(n);
    }

    public void visit(ConditionalExpression n) {
        visitNodeBefore(n);
        n.getCondition().accept(this);
        n.getThenExpression().accept(this);
        n.getElseExpression().accept(this);
        visitNodeAfter(n);
    }

    public void visit(EncapsulatedExpression n) {
        visitNodeBefore(n);
        n.getInner().accept(this);
        visitNodeAfter(n);
    }

    public void visit(FieldAccessExpression n) {
        visitNodeBefore(n);
        if (n.getScope() != null ) {
            n.getScope().accept(this);
        }
        visitNodeAfter(n);
    }

    public void visit(InstanceOfExpression n) {
        visitNodeBefore(n);
        n.getExpression().accept(this);
        n.getType().accept(this);
        visitNodeAfter(n);
    }

    public void visit(MethodInvocation n) {
        visitNodeBefore(n);
        n.getScope().accept(this);
        for (Expression nn : n) {
            nn.accept(this);
        }
        visitNodeAfter(n);
    }

    public void visit(NameExpression n) {
        visitNodeBefore(n);
        visitNodeAfter(n);
    }

    public void visit(NewInstanceExpression n) {
        visitNodeBefore(n);
        if (n.getScope() != null ) {
            n.getScope().accept(this);
        }
        n.getType().accept(this);
        for (Expression nn : n) {
            nn.accept(this);
        }
        visitNodeAfter(n);
    }

    public void visit(ThisExpression n) {
        visitNodeBefore(n);
        n.getClassExpression().accept(this);
        visitNodeAfter(n);
    }

    public void visit(SuperExpression n) {
        visitNodeBefore(n);
        n.getClassExpression().accept(this);
        visitNodeAfter(n);
    }

    public void visit(UnaryExpression n) {
        visitNodeBefore(n);
        n.getExpression().accept(this);
        visitNodeAfter(n);
    }

    public void visit(VariableDeclarationExpression n) {
        visitNodeBefore(n);
        n.getType().accept(this);
        for (VariableDeclarator nn : n) {
            nn.accept(this);
        }
        visitNodeAfter(n);
    }

    public void visit(Literal n) {
        visitNodeBefore(n);
        visitNodeAfter(n);
    }

    public void visit(AssertStatement n) {
        visitNodeBefore(n);
        n.getCheck().accept(this);
        n.getMessage().accept(this);
        visitNodeAfter(n);
    }

    public void visit(BlockStatement n) {
        visitNodeBefore(n);
        for (Statement nn : n) {
            nn.accept(this);
        }
        visitNodeAfter(n);
    }

    public void visit(BreakStatement n) {
        visitNodeBefore(n);
        visitNodeAfter(n);
    }

    public void visit(CatchClause n) {
        visitNodeBefore(n);
        n.getParameter().accept(this);
        n.getBody().accept(this);
        visitNodeAfter(n);
    }

    public void visit(ContinueStatement n) {
        visitNodeBefore(n);
        visitNodeAfter(n);
    }

    public void visit(TextLineStatement n) {
        visitNodeBefore(n);
        visitNodeAfter(n);
    }

    public void visit(ExpressionStatement n) {
        visitNodeBefore(n);
        n.getExpression().accept(this);
        visitNodeAfter(n);
    }

    public void visit(ForStatement n) {
        visitNodeBefore(n);
        for (Expression nn : n.getInit()) {
            nn.accept(this);
        }
        if (n.getCompare() != null ) {
            n.getCompare().accept(this);
        }
        for (Expression nn : n.getUpdate()) {
            nn.accept(this);
        }
        n.getBody().accept(this);
        visitNodeAfter(n);
    }

    public void visit(DoStatement n) {
        visitNodeBefore(n);
        n.getCondition().accept(this);
        n.getBody().accept(this);
        visitNodeAfter(n);
    }

    public void visit(ExplicitConstructorInvocationStatement n) {
        visitNodeBefore(n);
        for (Expression nn : n) {
            nn.accept(this);
        }
        visitNodeAfter(n);
    }

    public void visit(EmptyStatement n) {
        visitNodeBefore(n);
        visitNodeAfter(n);
    }

    public void visit(IfStatement n) {
        visitNodeBefore(n);
        n.getCondition().accept(this);
        n.getThenStatement().accept(this);
        if (n.getElseStatement() != null ) {
            n.getElseStatement().accept(this);
        }
        visitNodeAfter(n);
    }

    public void visit(LabeledStatement n) {
        visitNodeBefore(n);
        n.getStatement().accept(this);
        visitNodeAfter(n);
    }

    public void visit(ReturnStatement n) {
        visitNodeBefore(n);
        n.getExpression().accept(this);
        visitNodeAfter(n);
    }

    public void visit(SynchronizedStatement n) {
        visitNodeBefore(n);
        n.getMutex().accept(this);
        n.getBlock().accept(this);
        visitNodeAfter(n);
    }

    public void visit(SwitchEntryStatement n) {
        visitNodeBefore(n);
        n.getLabel().accept(this);
        for (Statement nn : n.getStatements()) {
            nn.accept(this);
        }
        visitNodeAfter(n);
    }

    public void visit(SwitchStatement n) {
        visitNodeBefore(n);
        n.getSelect().accept(this);
        for (SwitchEntryStatement nn : n) {
            nn.accept(this);
        }
        visitNodeAfter(n);
    }

    public void visit(ThrowStatement n) {
        visitNodeBefore(n);
        n.getExpression().accept(this);
        visitNodeAfter(n);
    }

    public void visit(TryStatement n) {
        visitNodeBefore(n);
        n.getTryBlock().accept(this);
        for (CatchClause nn : n.getCatchClauses()) {
            nn.accept(this);
        }
        n.getFinallyBlock().accept(this);
        visitNodeAfter(n);
    }

    public void visit(WhileStatement n) {
        visitNodeBefore(n);
        n.getCondition().accept(this);
        n.getBody().accept(this);
        visitNodeAfter(n);
    }

    public void visit(ClassOrInterfaceType n) {
        visitNodeBefore(n);
        visitNodeAfter(n);
    }

    public void visit(PrimitiveType n) {
        visitNodeBefore(n);
        visitNodeAfter(n);
    }

    public void visit(ReferenceType n) {
        visitNodeBefore(n);
        visitNodeAfter(n);
    }

    public void visitNodeBefore(AbstractASTNode e) {}

    public void visitNodeAfter(AbstractASTNode e) {}
}
